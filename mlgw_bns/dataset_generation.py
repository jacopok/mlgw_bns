from abc import ABC, abstractmethod
from collections.abc import Iterator
from dataclasses import dataclass
from typing import Dict, Optional, Union

import EOBRun_module  # type: ignore
import h5py
import numpy as np
from numpy.random import SeedSequence, default_rng

from .taylorf2 import (
    Af3hPN,
    Phif5hPN,
    PhifQM3hPN,
    PhifT7hPNComplete,
    compute_delta_lambda,
    compute_lambda_tilde,
)

SUN_MASS_SECONDS: float = 4.92549095e-06  # M_sun * G / c**3
TF2_BASE: float = 3.668693487138444e-19
# ( Msun * G / c**3)**(5/6) * Hz**(-7/6) * c / Mpc / s
AMP_SI_BASE: float = 4.2425873413901263e24
# Mpc / Msun**2 / Hz


class Dataset:
    r"""A dataset of data generated with some model.

    Includes:

    * frequencies at which the data are sampled
    * frequency indices
    * amplitude and phase residuals for all modes

    The amplitude residuals are defined as
    :math:`\log(A _{\text{EOB}} / A_{\text{PN}})`,
    while the phase residuals are defined as
    :math:`\phi _{\text{EOB}} - \phi_{\text{PN}}`.

    """

    # saving to file to be managed with https://docs.h5py.org/en/stable/quick.html

    total_mass: float = 2.8
    mass_sum_seconds: float = total_mass * SUN_MASS_SECONDS

    q_range = (1.0, 2.0)
    lambda1_range = (5.0, 5000.0)
    lambda2_range = (5.0, 5000.0)
    chi1_range = (-0.5, 0.5)
    chi2_range = (-0.5, 0.5)

    def __init__(
        self,
        filename: str,
        initial_frequency_hz: float,
        delta_f_hz: float,
        srate_hz: float,
        seed: int = 42,
    ):
        r"""
        Initialize dataset.

        Parameters
        ----------
        filename : str
                Name of the file where to save the data
                in hdf5 format.
        initial_frequency_hz : float
                Initial frequency from which the waveforms in this dataset
                should be generated by the effective one body model.
        delta_f_hz : float
                Frequency spacing for the generated waveforms.
        srate_hz : float
                Sampling rate in the time domain.
                The maximum frequency of the generated time-domain waveforms will be
                half of this value (see
                `Nyquist frequency <https://en.wikipedia.org/wiki/Nyquist_frequency>`_).
        seed : int
                Seed for the random number generator used when generating
                waveforms for the training.
                Defaults to 42.

        Examples
        --------
        >>> dataset = Dataset(filename='data', initial_frequency_hz=20., delta_f_hz=1./256., srate_hz=4096.)
        >>> print(dataset.filename)
        data
        """

        self.filename = filename
        self.initial_frequency_hz = initial_frequency_hz
        self.delta_f_hz = delta_f_hz
        self.srate_hz = srate_hz

        self.seed_sequence = SeedSequence(seed)

    def save(self) -> None:
        pass

    def load(self) -> None:
        with h5py.File(self.filename, "r") as file:
            self.frequencies = file["data"]

    def taylor_f2_prefactor(self, eta: float) -> float:
        """Prefactor by which to multiply the waveform
        generated by TaylorF2.

        Parameters
        ----------
        eta : float
                Mass ratio of the binary
        """
        return TF2_BASE * AMP_SI_BASE / eta / self.total_mass ** 2

    def mlgw_bns_prefactor(self, eta: float) -> float:
        """Prefactor by which to multiply the waveform
        generated by `mlgw_bns`.

        Parameters
        ----------
        eta : float
                Mass ratio of the binary
        """
        return self.total_mass ** 2 / AMP_SI_BASE * eta


@dataclass
class WaveformParameters:

    r"""Parameters for a single waveform.

    Parameters
    ----------

    q : float
            Mass ratio of the system, :math:`q = m_1 / m_2`,
            where :math:`m_1 \geq m_2`, so :math:`q \geq 1`.
    l1 : float
            Tidal polarizability of the larger star.
            In papers it is typically denoted as :math:`\Lambda_1`;
            for a definition see for example section D of
            `this paper <http://arxiv.org/abs/1805.11579>`_.
    l2 : float
            Tidal polarizability of the smaller star.
    chi1 : float
            Aligned dimensionless spin component of the larger star.
            The dimensionless spin is defined as
            :math:`\chi_i = S_i / m_i^2` in
            :math:`c = G = 1` natural units, where
            :math:`S_i` is the :math:`z` component
            of the dimensionful spin vector.
            The :math:`z` axis is defined as the one which is
            parallel to the orbital angular momentum of the binary.
    chi2 : float
            Aligned spin component of the smaller star.
    """

    q: float
    l1: float
    l2: float
    chi1: float
    chi2: float
    dataset: Dataset

    @property
    def eta(self):
        r"""Symmetric mass ratio of the binary.

        It is defined as :math:`\eta = \mu / M`, where
        :math:`\mu  = (1 / m_1 + 1/ m_2)^{-1}`
        and :math:`M = m_1 + m_2`.

        It can also be expressed as
        :math:`\eta = m_1 m_2 / (m_1 + m_2)^2 = q / (1+q)^2`,
        where :math:`q = m_1 / m_2` is the mass ratio.

        It is also sometimes denoted as :math:`\nu`.
        """
        return self.q / (1.0 + self.q) ** 2

    @property
    def m1(self):
        """Mass of the heavier star in the system, in solar masses."""
        return self.dataset.total_mass / (1 + 1 / self.q)

    @property
    def m2(self):
        """Mass of the lighter star in the system, in solar masses."""
        return self.dataset.total_mass / (1 + self.q)

    @property
    def lambdatilde(self):
        r"""Symmetrized tidal deformability parameter :math:`\widetilde\Lambda`,
        which gives the largest contribution to the waveform phase.
        For the precise definition see equation 5 of `this paper <http://arxiv.org/abs/1805.11579>`_."""
        return compute_lambda_tilde(self.m1, self.m2, self.l1, self.l2)

    @property
    def dlambda(self):
        r"""Antisymmetrized tidal deformability parameter :math:`\delta \widetilde\Lambda`,
        which gives the next-to-largest contribution to the waveform phase.
        For the precise definition see equation 27 of `this paper <http://arxiv.org/abs/2102.00017>`_."""
        return compute_delta_lambda(self.m1, self.m2, self.l1, self.l2)

    @property
    def teobresums(self) -> Dict[str, Union[float, int]]:
        """Parameter dictionary in a format compatible with
        TEOBResumS.

        The parameters are all converted to natural units.
        """
        return {
            "q": self.q,
            "Lambda1": self.l1,
            "Lambda2": self.l2,
            "chi1": self.chi1,
            "chi2": self.chi2,
            "M": self.dataset.total_mass,
            "distance": 1.0,
            "initial_frequency": self.dataset.initial_frequency_hz
            * self.dataset.mass_sum_seconds,
            "use_geometric_units": 1,
            "interp_uniform_grid": 0,
            "domain": 1,  # Fourier domain
            "srate_interp": self.dataset.srate_hz * self.dataset.mass_sum_seconds,
            "df": self.dataset.delta_f_hz * self.dataset.mass_sum_seconds,
            "interp_FD_waveform": 1,
            "inclination": 0.0,
            "output_hpc": 0,
            "output_dynamics": 0,
            "time_shift_FD": 1,
        }

    def taylor_f2(self, f: np.ndarray) -> Dict[str, Union[float, int, np.ndarray]]:
        """Parameter dictionary in a format compatible with
        the custom implemnentation of TaylorF2 implemented within `mlgw_bns`.

        Parameters
        ----------
        f : np.ndarray
                The frequencies where to compute the
                waveform, to be given in natural units
        """

        return {
            "f": f / self.dataset.mass_sum_seconds,
            "q": self.q,
            "s1x": 0,
            "s1y": 0,
            "s1z": self.chi1,
            "s2y": 0,
            "s2x": 0,
            "s2z": self.chi2,
            "lambda1": self.l1,
            "lambda2": self.l2,
            "f_min": self.dataset.initial_frequency_hz,
            "phi_ref": 0,
            "phaseorder": 11,
            "tidalorder": 15,
            "usenewtides": 1,
            "usequadrupolemonopole": 1,
            "mtot": self.dataset.total_mass,
            "s1x": 0,
            "s1y": 0,
            "s2x": 0,
            "s2y": 0,
            "Deff": 1.0,
            "phiRef": 0.0,
            "timeShift": 0.0,
            "iota": 0.0,
        }


class ParameterGenerator(ABC, Iterator):
    def __init__(self, dataset: Dataset, seed: Optional[int] = None):

        self.dataset = dataset

        if seed is None:
            self.rng = default_rng(self.dataset.seed_sequence.generate_state(1)[0])
        else:
            self.rng = default_rng(seed)

    def __iter__(self):
        return self

    @abstractmethod
    def __next__(self) -> WaveformParameters:
        pass


class UniformParameterGenerator(ParameterGenerator):
    def __next__(self) -> WaveformParameters:
        q = self.rng.uniform(*self.dataset.q_range)
        lambda_1 = self.rng.uniform(*self.dataset.lambda1_range)
        lambda_2 = self.rng.uniform(*self.dataset.lambda2_range)
        chi_1 = self.rng.uniform(*self.dataset.chi1_range)
        chi_2 = self.rng.uniform(*self.dataset.chi2_range)

        return WaveformParameters(q, lambda_1, lambda_2, chi_1, chi_2, self.dataset)


class WaveformGenerator(ABC):
    @abstractmethod
    def post_newtonian_amplitude(
        self, params: WaveformParameters, frequencies: np.ndarray
    ) -> np.ndarray:
        pass

    @abstractmethod
    def post_newtonian_phase(
        self, params: WaveformParameters, frequencies: np.ndarray
    ) -> np.ndarray:
        pass

    @abstractmethod
    def effective_one_body_waveform(self, params: WaveformParameters) -> np.ndarray:
        pass


class TEOBResumSGenerator(WaveformGenerator):
    def post_newtonian_amplitude(
        self, params: WaveformParameters, frequencies: np.ndarray
    ) -> np.ndarray:
        par_dict = params.taylor_f2(frequencies)

        return (
            Af3hPN(
                par_dict["f"],
                par_dict["mtot"],
                params.eta,
                par_dict["s1x"],
                par_dict["s1y"],
                par_dict["s1z"],
                par_dict["s2x"],
                par_dict["s2y"],
                par_dict["s2z"],
                Lam=params.lambdatilde,
                dLam=params.dlambda,
                Deff=par_dict["Deff"],
            )
            * params.dataset.taylor_f2_prefactor(params.eta)
        )

    def post_newtonian_phase(
        self, params: WaveformParameters, frequencies: np.ndarray
    ) -> np.ndarray:
        par_dict = params.taylor_f2(frequencies)

        phi_5pn = Phif5hPN(
            par_dict["f"],
            par_dict["mtot"],
            params.eta,
            par_dict["s1x"],
            par_dict["s1y"],
            par_dict["s1z"],
            par_dict["s2x"],
            par_dict["s2y"],
            par_dict["s2z"],
        )

        # Tidal and QM contributions
        phi_tidal = PhifT7hPNComplete(
            par_dict["f"],
            par_dict["mtot"],
            params.eta,
            par_dict["lambda1"],
            par_dict["lambda2"],
        )
        # Quadrupole-monopole term
        # [https://arxiv.org/abs/gr-qc/9709032]
        phi_qm = PhifQM3hPN(
            par_dict["f"],
            par_dict["mtot"],
            params.eta,
            par_dict["s1x"],
            par_dict["s1y"],
            par_dict["s1z"],
            par_dict["s2x"],
            par_dict["s2y"],
            par_dict["s2z"],
            par_dict["lambda1"],
            par_dict["lambda2"],
        )

        # I use the convention h = h+ + i hx
        phase = -phi_5pn - phi_tidal - phi_qm

        return phase - phase[0]

    def effective_one_body_waveform(self, params: WaveformParameters):
        r"""Generate an EOB waveform with TEOB.

        Examples:
        >>> tg = TEOBResumSGenerator()
        >>> p = WaveformParameters(1, 300, 300, .3, -.3, Dataset('test', 20., 1./256., 4096.))
        >>> f, waveform = tg.effective_one_body_waveform(p)
        >>> print(len(waveform))
        519169
        >>> print(waveform.dtype)
        complex128
        """

        par_dict = params.teobresums

        N = 256

        # tweak initial frequency backward by a few samples
        # this is needed because of a bug in TEOBResumS
        # causing the phase evolution not to behave properly
        # at the beginning of integration
        # TODO remove this once the TEOB bug is fixed

        f0 = par_dict["initial_frequency"]
        df = par_dict["df"]
        new_f0 = f0 - df * N
        par_dict["initial_frequency"] = new_f0

        f_spa, rhpf, ihpf, rhcf, ihcf = EOBRun_module.EOBRunPy(par_dict)

        f_spa = f_spa[N:]

        waveform = (rhpf - 1j * ihpf)[N:]

        # + 1j * (rhcf -1j * ihcf)

        return (f_spa, waveform)
